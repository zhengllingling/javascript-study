/** 
 * 代码层面
 * 
 * 1.v-if 和 v-show 区分场景使用
 * v-if 惰性的 不会频繁切换条件 
 * v-show display 频繁切换条件
 * 
 * 2.computed和watch区分场景使用
 * computed 依赖其他属性 有缓存 只有依赖的属性改变时才会计算
 * 依赖其他属性，并需要计算时 使用computed 可以利用computed的缓存特性避免频繁计算
 * 
 * watch 监听属性 只要属性有变换 就会执行对应的回调函数
 * 适用于当我们需要在数据变化时执行异步或开销较大的操作时
 * 
 * 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
 * （1）v-for 遍历必须为 item 添加 key
 * （2）v-for 遍历避免同时使用 v-if
 *  v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，
 * 尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。
 * 
 * 1.4、长列表性能优化
 * Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，
 * 然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，
 * 我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，
 * 那如何禁止 Vue 劫持我们的数据呢？
 * 可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了
 * 
    export default {
        data: () => ({
            users: {}
        }),
        async created() {
            const users = await axios.get("/api/users");
            this.users = Object.freeze(users);
        }
    };

    1.5、事件的销毁
    Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。
    如果在 js 内使用 addEventListener 等方式是不会自动销毁的，
    我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露

    1.6、图片资源懒加载
    对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 
    等到滚动到可视区域后再去加载。
    这样对于页面加载性能上会有很大的提升，也提高了用户体验。
    使用 Vue 的 vue-lazyload 插件可以实现

    1.7、路由懒加载
    Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，
    当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。
    如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。
    这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来

    1.8、第三方插件的按需引入
    我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，
    我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。

    1.9、优化无限列表性能
    如果你的应用存在非常长或者无限滚动的列表，
    那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间

    二、Webpack 层面的优化
    2.1、Webpack 对图片进行压缩
    在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，
    对小于 limit 的图片转化为 base64 格式，其余的不做操作。
    所以对有些较大的图片资源，在请求资源的时候，加载会很慢，
    我们可以用 image-webpack-loader来压缩图片

    2.2、减少 ES6 转为 ES5 的冗余代码
    babel-plugin-transform-runtime

    2.3、提取公共代码

    2.5、提取组件的 CSS
    当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。
    这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。
    将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。
 */